# This is personal work for '武汉大学计算机学院 操作系统课程设计 内核实验',directed by Liu Huajun. #
> This project finished Task一 and Task二's first sub-task.

## This project meets the requirements below: ##

# 一、系统调用实验 #
## 实验任务 ##
> 添加并测试自定义系统调用
    
> 在RISC-V体系结构上运行的xv6操作系统中引入一个新的系统调用，该调用执行一个简单任务，比如返回系统中当前进程的数量。
## 实验目的 ##
> 1.	熟悉RISC-V体系结构。
> 2.	理解xv6中系统调用的工作原理。
> 3.	获得修改xv6源代码的经验。
## 实验步骤 ##

> 1.	定义系统调用接口
>     在`user/user.h`头文件中创建一个新的系统调用函数原型。在本实验中，比如可能命名为`int getprocs(void);`。
> 2.	实现系统调用
>     在xv6内核中，创建一个新的C文件或在现有文件中来实现系统调用。该函数可能如下所示：
>     `int sys_getprocs(void)
>     {
>      		 return getprocs();
>     }`
>     然后在内核中实现实际的`getprocs()`函数，该函数与进程表交互以计算活跃的进程数量。
> 3.	分配系统调用号
>     通过编辑`kernel/syscall.h`文件并添加一个新的`define`，为你的自定义系统调用分配一个唯一的系统调用号，例如：
>     `#define SYS_getprocs 22`
> 4.	更新系统调用调度程序
>     修改`kernel/syscall.c`中的系统调用调度器函数，以处理新的系统调用编号。你还需要为`sys_getprocs`函数添加一个原型。
>     `extern int sys_getprocs(void);
>     
>     void syscall(void)
>     {
>       
>       switch(myproc()->trapframe->a7){
>     
>     case SYS_getprocs:
>       myproc()->trapframe->a0 = sys_getprocs();
>       break;
>     
>       }
>     }`
> 5.	用户空间库
>     编辑`user/usys.pl`脚本以定义新系统调用的用户空间映射，它将生成`usys.S`汇编代码。
>     添加类似的行：
>     `entry("getprocs");`
> 6.	测试系统调用
>     编写一个用户程序，调用`getprocs()`并将计数显示到控制台。
>     `#include "kernel/types.h"`
>     `#include "user/user.h"`
> 
>     `int main(int argc, char *argv[])
>     {
>       int count = getprocs();
>       printf("There are %d active processes.\n", count);
>       exit(0);
>     }`
> 在进行这些更改后，需要重新编译内核和用户程序。
## 注意事项 ##
> 1.	确保在xv6源码仓库中编辑正确的文件。
> 2.	保持对源代码的持续备份，以防工作丢失。
> 3.	增量测试以便及早发现错误。
> 4.	注意xv6中用于系统调用的约定，包括错误处理和返回值。
  
- 按照以上步骤，你应该能够在RISC-V的xv6中创建并测试一个新的系统调用。这是一个操作框架，你需要通过探索详细填写具体内容，比如计算进程数量的实际机制，这将涉及遍历xv6的进程表。

# 二、内存管理实验 #
## *以下任务二选一* ##
> 任务一是在内核空间实现动态内存分配
> 
> 任务二则是优化改进用户空间已实现的动态内存分配器。
## 实验任务一：动态内存分配器的实现（内核空间） ##
> 设计并实现一个类似malloc的动态内存分配器，用于为用户态程序运行时分配和释放不同大小的内存块。
## 实验目的 ##
> 1.	认识和实践xv6操作系统内存管理方法。
> 2.	通过设计和实现类似malloc的动态内存分配器，理解操作系统如何处理内存分配和回收，以及如何动态处理不同大小内存块的请求。
## 实验步骤 ##
> 1.	研究当前xv6系统中内存管理的机制，特别是`kalloc.c`和`vm.c`中的代码，理解内核使用`kalloc()`和`kfree()`来分配和释放内存的机制。`kalloc()`仅用于xv6的内核空间，并且它总是分配固定大小的内存块(4KB)。
> 2.	内核空间中，Free memory段落，在最高地址区域，开辟16MB或8MB的堆。
•原先整个Free memory段落纳入`kmalloc()`的管理，按页为单位分配回收<br>
•现在要求从Free memory段落的顶部扣减8MB或16MB，`kmalloc()`仍按原机制分配回收，只是管理的内存总量少了8MB或16MB，现有内核代码都不受影响<br>
•扣出来的8MB或16MB，另起炉灶，搭建一个堆，以字节为单位的分配释放机制<br>
•堆和`kmalloc()`并行工作，各管理内核空间中的一片区域<br>
> 3.	提供`malloc()`、`free()`函数，不需要类似`sbrk()`的堆扩容功能
> 4.	为了演示效果，须在内核中增加一个演示函数，连续执行一系列的堆分配、堆释放，并在屏幕上输出必要堆状态信息
> 5.	此外还需增加一个（或两个）系统调用，应用程序通过系统调用，启动演示。

## 实验任务二：优化用户空间的动态内存分配器（用户空间） ##
> 优化xv6中用户空间的动态内存分配器，以提高内存利用率并减少内存碎片。
 
## 实验目的 ##
> 1.	深入理解动态内存分配的原理和各种内存分配策略的优缺点，包括首次适配、最佳适配、最差适配等。
> 2.	在优化内存分配器的过程中，学习掌握如何通过合并空闲内存块、按大小划分空闲列表、伙伴算法等策略来减少内存碎片，提高内存利用效率。
> 3.	深入理解xv6的内存管理系统，以及RISCV架构对内存管理的支持和限制。
>  
## 实验步骤 ##
 
> 1.	研究背景资料：学习相关内存管理和分配算法。
> 2.	分析现有实现：理解xv6用户空间的内存管理代码/user/umalloc.c，对其性能和可能的问题给出自己的结论。
> 3.	设计改进方案：设计一种或多种可能改进内存利用率和减少内存碎片的策略。
> 4.	编码实现：在xv6中实现新的内存分配策略。
> 5.	运行测试：运行和调试测试用例，验证新策略的有效性。
> 6.	性能评估：通过对比实验，评价新策略与旧策略的性能差异。
> 7.	结果记录：记录实验过程和数据，撰写实验报告。
>  
## 注意事项 ##
xv6中用户空间的动态分配的回收策略是一个有效的策略，但仍然存在改进空间。以下是一些可能的改进的方向：  
> 1.是否可以采用更合适的数据结构来快速定位空闲块，从而加快空闲块的合并过程。  
> 2.如何设计搜索策略能提高搜索合适空闲块的效率？比如将空闲列表分割为大小不同的若干空闲列表。每个空闲列表只包含一定大小范围的空闲块。  
> 3.	如何选择合适的最小内存分配单元的大小，在可能产生的内部碎片和外碎片间达成一种平衡。通过调整粒度大小，在系统性能和内存利用率之间寻求最佳平衡。  
> 4.	是否可以推迟合并时机，不是在每次 free 时就立即合并相邻空闲块，而是在合适的时机进行合并，可能减少一些不必要的合并操作。  
> 5.	是否可以采用复合策略？除了首次适配（First-Fit），还可以实现最佳适配（Best-Fit），最差适配（Worst-Fit）或快速适配（Quick-Fit）等策略，根据具体应用和内存使用模式选择最合适的策略。  
> 6.	采用紧凑（Compaction）技术，这是一个比较极端的内存压缩策略，即通过移动已分配的内存块来整理空闲块，这样可以将多个小的碎片空间合并成一个大的空闲块，但这个过程需要移动内存内容，可能会显著影响性能。  

----------

> 大家可以根据各自的能力选择但不限于以上一种或多种策略来实现对现有用户空间的动态分配策略进行改进。为了验证策略的有效性，需要编写标准化的测试场景，来确保你的实验结果既可重现又具有普遍意义。首先确定你希望模拟的场景，例如是计算密集型、IO密集型还是内存密集型。决定数据的分配大小，如固定大小的内存分配、小内存分配交替大内存分配，或者随机大小的内存分配。然后创建操作序列，定义一系列内存操作（分配、释放）的序列。这个序列应当旨在模仿实际应用程序的行为，可以有固定模式的分配/释放周期，也可以是随机化的。在相同的测试场景下，对比不同策略下的内存利用率、碎片率和时间性能。
 

----------

内存管理是一个复杂且容易出错的任务，在设计和实现过程中需要仔细检查可能的错误，并实现适当的错误处理程序。

